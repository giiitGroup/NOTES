<h1> FLUTTER 学习笔记 </h1>


# 安装

[安装教程](https://flutterchina.club/get-started/install/)

环境变量配置和sdk，可通过flutter doctor命令检测本地环境

# 项目目录结构

目前主要使用pubspec.yaml配置依赖，在lib中编写页面和逻辑

```
--.dart_tool/

--android    // 需要安卓原生实现的功能

--build

--ios    // 需要ios原生实现的功能

--lib    // 页面的编写

----assets

----components

----configs

----pages

----routes

----utils

----main.bk.dart    // 

----main.dart    // 入口文件，runApp()是入口方法，类似vue中的main.js和new Vue()

--test

.flutter-plugins

.flutter-plugins-dependencies

.metadata

.packages

pubspec.lock    // 依赖配置文件，类似于package.json，层级严格按照缩进

pubspec.yaml
```
> dart在运行时有类似webpack的热重载，但是在添加新widget后最好是重新运行，确保更改生效

***

# 开发
## widget
[widget索引](https://flutterchina.club/widgets/widgetindex/)

在widget声明UI，通过build构建UI

> 所有的都是widget，包括flutter工程本身
> 
> 通过嵌套widget生成element tree，但不操作element
***

## 布局
Scaffold 布局容器，常用的Material组件，包含页面基本元素

SingleChildScrollView 滚动组件，页面内容超出不多时使用

### 尺寸限制类容器
- ### ConstrainedBox
  可以对宽度高度进行约束
    > 需要指定constraints，嵌套的ConstrainedBox取约束范围的交集，最大(小)约束取最小(大)值。
    ```javascript
    ConstrainedBox(
        constraints: BoxConstraints(
            minWidth: double.infinity, //宽度尽可能大
            minHeight: 50.0 //最小高度为50像素
        ),
        child: Container(
            height: 5.0, 
            child: ... 
        ),
    )
    ```
    BoxConstraints.tight(Size size) 给定大小限制

    const BoxConstraints.expand() 尽可能大的填充容器

- ### SizedBox
    固定宽高
    ```javascript
    SizedBox(
        width: 80.0,
        height: 80.0,
        child: ...
    )
    ```
    等价于定制宽高的ConstrainedBox
    ```javascript
    ConstrainedBox(
        constraints: BoxConstraints.tightFor(width: 80.0,height: 80.0),
        child: ... 
    )
    ```
    等价于
    ```javascript
    ConstrainedBox(
        constraints: BoxConstraints(minHeight: 80.0,maxHeight: 80.0,minWidth: 80.0,maxWidth: 80.0),
        child: ... 
    )
    ```
        
- ### UnconstrainedBox
    允许其子组件按照其本身大小绘制，可以"清除"ConstrainedBox的约束（子组件可以根据指定尺寸展示，但是本身仍然遵守约束，即组件的占用空间受约束）。
    ```javascript
    ConstrainedBox(
        constraints: BoxConstraints(...),
        child: UnconstrainedBox(
            child: ...
        )
    )
    ```
- ### AspectRatio
    固定宽高比
    ```javascript
    AspectRatio(
        aspectRatio: 2 / 1,
        child: ...
    )
    ```
- ### FractionallySizedBox
    根据父容器宽高的百分比来设置子组件宽高
    ```javascript
    FractionallySizedBox(
        widthFactor: .7,
        alignment: Alignment.centerLeft,
        aspectRatio: 2 / 1,
        child: ...
    )
    ```
- ### LimitedBox
  如果父组件没有约束宽（高），则根据maxWidth（maxHeight）进行约束。
  > 不约束子组件尺寸的组件：ListView、Row、Column、UnconstrainedBox等
    ```javascript
    LimitedBox(
        maxWidth: 100.0,
        maxHeight: 100.0,
        child: ...
    )
    ```
    ***
> 注：
> - SizedBox和FractionallySizedBox可以没有子组件，但是仍占用空间，可以作为间隔组件使用.
> - 实际上ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的.
> ```javascript
>     @override
>     RenderConstrainedBox createRenderObject(BuildContext context) {
>        return new RenderConstrainedBox(
>            additionalConstraints: ...
>        );
>     }
> ```
> - UnconstrainedBox对子组件尺寸约束的3种情况
>   - constrainedAxis = null时,UnconstrainedBox 不受约束
>   - constrainedAxis = Axis.vertical 宽度不受约束
>   - constrainedAxis = Axis.horizontal 高度不受约束
> - double.infinity 尺寸约束中，相对父元素尽可能大

***
## BuildContext

[参考博客](https://www.jianshu.com/p/509b77b26b78)

widget上下文环境对象，实际是element类的实现（阻止直接操作element），可以传递状态和数据。

供navigator、scaffold等调用时作为参数，标记在widget tree的位置，寻找上级节点，在tree中正确的位置执行函数。

### 视图树装载过程
> ### StatelessWidget
> - 首先它会调用StatelessWidget的 createElement 方法，并根据这个widget生成StatelesseElement对象。
> - 将这个StatelesseElement对象挂载到element树上。
> - StatelesseElement对象调用widget的build方法，并将element自身作为BuildContext传入。
> 
> ### StatefulWidget
> - 首先同样也是调用StatefulWidget的 createElement方法，并根据这个widget生成StatefulElement对象，并保留widget引用。
> - 将这个StatefulElement挂载到Element树上。
> - 根据widget的 createState 方法创建State。
> - StatefulElement对象调用state的build方法，并将element自身作为BuildContext传入。
***
## StatefulWidget和StatelessWidget

StatefulWidget：存在交互和数据更新的，初始化需要createState关联state

StatelessWidget：根据所给配置进行展示的，初始化后直接build
> StatefulWidget可替换StatefulWidget和StatelessWidget，但是更新state时会触发自身和子widget的重新构建(build)。
> 
> 使用类似于双向绑定，但实现是针对发生变化的widget标记为需要build，会根据发生变化的state重新构建widget。尽量准确使用。



***
## 路由 router.dart

引入每个页面，然后将每个widget的builder暴露出来（_routes）

> [RouteSettings](https://github.com/flutter/flutter/blob/9b2d32b605630f28625709ebd9d78ab3016b2bf6/packages/flutter/lib/src/widgets/navigator.dart#L465) 包含路由名称和参数
> 
> PageRouteBuilder 实现自定义转场动画

***

## const，final和static

const 不可更改的常量，编译时常量

final 运行时常量（第一次运行）

static  声明类的静态变量（方法），多个实例共享该变量（方法）实例，需要通过类名访问，不需要实例也可访问。

> 静态方法不可以访问非静态变量，非静态方法可以访问静态变量

***

## VoidCallback

部件通信，通过VoidCallback注册，触发后在widget中监听
***
## super

重写initState或dispose时需要先使用super调用覆盖
***
## SharedPreferences
flutter的本地存储
```javascript
SharedPreferences prefs = await SharedPreferences.getInstance();
prefs.setString(key, value)
prefs.setBool(key, value)
prefs.setDouble(key, value)
prefs.setInt(key, value)
prefs.setStringList(key, value)

prefs.remove(key); //删除指定键
prefs.clear();//清空键值对
```
注：get时是异步操作
